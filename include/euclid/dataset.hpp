#pragma once

#include <cstdint>
#include <string>

#include "euclid/board.hpp"
#include "euclid/encode.hpp"
#include "euclid/search.hpp"

namespace euclid {

// Simple binary dataset format (v1):
// Header (32 bytes):
//   magic[8] = "EUCLIDDS"
//   u32 version = 1
//   u32 feature_dim = EncodedInputSpec::kTotal (781)
//   u64 record_count
//   u32 flags (bit0 = label_is_wdl)
//   u32 reserved
//
// Record (fixed size):
//   u64 key (Board::hash())
//   f32 label (WDL from side-to-move POV: +1 win, 0 draw, -1 loss)
//   f32 features[feature_dim] (encode_12x64)

inline constexpr char DATASET_MAGIC[8] = {'E','U','C','L','I','D','D','S'};
inline constexpr std::uint32_t DATASET_VERSION = 1;
inline constexpr std::uint32_t DATASET_FLAG_LABEL_WDL = 1u << 0;

struct DatasetHeader {
  char     magic[8];       // 0..7
  uint32_t version;        // 8..11
  uint32_t feature_dim;    // 12..15
  uint64_t record_count;   // 16..23
  uint32_t flags;          // 24..27
  uint32_t reserved;       // 28..31
};

static_assert(sizeof(DatasetHeader) == 32, "DatasetHeader must be 32 bytes");


struct DatasetGenConfig {
  int games = 1;
  int maxPlies = 200;
  bool includeAborted = false; // if false, aborted games contribute zero records
};

struct DatasetGenStats {
  std::uint64_t games = 0;
  std::uint64_t records = 0;

  std::uint64_t whiteWins = 0;
  std::uint64_t blackWins = 0;
  std::uint64_t draws = 0;
  std::uint64_t aborted = 0;
};

// Writes a dataset generated by deterministic selfplay().
// Returns true on success; on failure returns false and fills `err` if provided.
bool write_selfplay_dataset(
  const std::string& outPath,
  const Board& start,
  const DatasetGenConfig& cfg,
  SearchLimits baseLimits,
  DatasetGenStats* stats = nullptr,
  std::string* err = nullptr
);

} // namespace euclid
